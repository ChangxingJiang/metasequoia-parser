"""
Auto generated by Metasequoia Parser
"""

import metasequoia_parser as ms_parser




def h0(a,b,c):
    a.append(2)
    b.append(c.v)
    return s2,True

def h1(a,b,c):
    a.append(3)
    b.append(c.v)
    return s3,True

def h2(a,b,c):
    a.append(4)
    b.append(c.v)
    return s4,True

def h3(a,b,c):
    a.append(5)
    b.append(c.v)
    return s5,True

E0={0}

def r0(a,b,_):
    v = f'{b[-2]}{b[-1]}'
    assert a[-3] in E0
    b[-2:]=[v]
    a[-2:]=[1]
    return s1,False

def r1(a,b,_):
    v = f'{b[-4]}{b[-3]}{b[-2]}{b[-1]}'
    assert a[-5] in E0
    b[-4:]=[v]
    a[-4:]=[1]
    return s1,False
def p(a,b,c):
    return None,True


def s0(a,b,c):
    assert c.i==1
    return h0(a,b,c)


def s1(a,b,c):
    assert c.i==0
    return p(a,b,c)


def s2(a,b,c):
    assert c.i==2
    return h1(a,b,c)


SH3={0:r0,3:h2,}


def s3(a,b,c):
    m=SH3[c.i]
    return m(a,b,c)


def s4(a,b,c):
    assert c.i==4
    return h3(a,b,c)


def s5(a,b,c):
    assert c.i==0
    return r1(a,b,c)



def parse(lexical_iterator: ms_parser.lexical.LexicalBase):
    a = [0]
    b = []

    action = s0
    c = lexical_iterator.lex()
    next_terminal = False
    try:
        while action:
            if next_terminal is True:
                c = lexical_iterator.lex()
            action, next_terminal = action(a, b, c)
    except KeyError as e:
        next_terminal_list = []
        for _ in range(10):
            if c.is_end:
                break
            next_terminal_list.append(c.v)
            c = lexical_iterator.lex()
        next_terminal_text = "".join(next_terminal_list)
        raise KeyError("解析失败:", next_terminal_text) from e

    return b[0]
